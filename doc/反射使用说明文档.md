# 反射使用说明文档

## 文档信息

- **创建日期**: 2025-12-29
- **文档类型**: 技术文档
- **版本**: 1.0

---

## 一、概述

### 1.1 为什么使用反射？

项目中多处使用反射机制，主要目的是：

1. **编译期无依赖**：避免在编译时强制依赖第三方库（如 MyBatis、JPA、Canal、Binlog 等）
2. **运行时按需加载**：只有在运行时才加载和使用这些库，如果库不存在可以降级处理
3. **提高灵活性**：支持多种数据库操作方式（JDBC、MyBatis、JPA），可以根据项目情况选择
4. **降低耦合度**：`common` 模块不需要强制依赖所有可能的框架

### 1.2 反射使用原则

- ✅ **统一异常处理**：所有反射调用都统一捕获异常并转换为 `RuntimeException`
- ✅ **详细注释说明**：每个反射调用都有详细注释，说明类名、方法原型、作用等
- ✅ **降级方案**：如果反射调用失败，提供降级方案（如轮询同步）

---

## 二、反射使用位置汇总

### 2.1 BinlogListener（MySQL Binlog 监听）

**文件位置**：`common/src/main/java/com/lixiangyu/common/migration/BinlogListener.java`

#### 2.1.1 BinaryLogClient 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **169** | `Class.forName()` | `com.github.shyiko.mysql.binlog.BinaryLogClient` | - | 检查 BinaryLogClient 类是否存在 |
| **206** | `Class.forName()` | `com.github.shyiko.mysql.binlog.BinaryLogClient` | - | 加载 BinaryLogClient 类 |
| **207** | `getConstructor().newInstance()` | `BinaryLogClient` | `BinaryLogClient(String hostname, int port)` | 创建 BinaryLogClient 实例，连接到 MySQL 服务器 |
| **208** | `getMethod().invoke()` | `BinaryLogClient` | `void setUsername(String username)` | 设置连接 MySQL 的用户名 |
| **212** | `getMethod().invoke()` | `BinaryLogClient` | `void setBinlogFilename(String filename)` | 设置 binlog 文件名（用于断点续传） |
| **215** | `getMethod().invoke()` | `BinaryLogClient` | `void setBinlogPosition(long position)` | 设置 binlog 位置（用于断点续传） |
| **1057** | `getMethod().invoke()` | `BinaryLogClient` | `void connect()` | 连接到 MySQL 服务器，开始监听 binlog |
| **1064** | `getMethod().invoke()` | `BinaryLogClient` | `void disconnect()` | 断开与 MySQL 服务器的连接 |

#### 2.1.2 EventListener 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **227** | `Class.forName()` | `com.github.shyiko.mysql.binlog.event.EventListener` | - | 加载 EventListener 接口 |
| **230-239** | `Proxy.newProxyInstance()` | `EventListener` | `void onEvent(Event event)` | 创建动态代理实现 EventListener 接口 |
| **241** | `getMethod().invoke()` | `BinaryLogClient` | `void registerEventListener(EventListener listener)` | 注册事件监听器到 BinaryLogClient |

#### 2.1.3 Binlog 事件相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **272** | `getMethod().invoke()` | `WriteRowsEvent` | `long getTableId()` | 获取 INSERT 事件对应的表ID |
| **273** | `getMethod().invoke()` | `WriteRowsEvent` | `List<Row> getRows()` | 获取 INSERT 事件中的行数据 |
| **289** | `getMethod().invoke()` | `UpdateRowsEvent` | `long getTableId()` | 获取 UPDATE 事件对应的表ID |
| **290** | `getMethod().invoke()` | `UpdateRowsEvent` | `List<Pair<Row, Row>> getRows()` | 获取 UPDATE 事件中的行数据对（before/after） |
| **310** | `getMethod().invoke()` | `DeleteRowsEvent` | `long getTableId()` | 获取 DELETE 事件对应的表ID |
| **311** | `getMethod().invoke()` | `DeleteRowsEvent` | `List<Row> getRows()` | 获取 DELETE 事件中的行数据 |

#### 2.1.4 Row 对象相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **489** | `getMethod()` | `Row` | `Object getValue(int columnIndex)` | 检查 Row 对象是否有 getValue 方法 |
| **492** | `getMethod().invoke()` | `Row` | `Object getValue(int columnIndex)` | 从 Row 对象中获取指定索引的列值 |

#### 2.1.5 Pair 对象相关反射（UPDATE 事件）

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **606** | `getMethods()` | `Pair` | - | 获取 Pair 对象的所有公共方法 |
| **610-612** | `getMethod().invoke()` | `Pair` | `Object getKey()` | 尝试通过 getKey() 获取 Pair 的第一个元素（before row） |
| **617-619** | `getMethod().invoke()` | `Pair` | `Object getFirst()` | 尝试通过 getFirst() 获取 Pair 的第一个元素 |
| **624-626** | `getMethod().invoke()` | `Pair` | `Object getLeft()` | 尝试通过 getLeft() 获取 Pair 的第一个元素 |
| **631-633** | `getDeclaredField().get()` | `Pair` | 字段：`key` | 尝试通过字段访问获取 Pair 的第一个元素 |
| **639-641** | `getDeclaredField().get()` | `Pair` | 字段：`first` | 尝试通过字段访问获取 Pair 的第一个元素 |
| **664** | `getMethods()` | `Pair` | - | 获取 Pair 对象的所有公共方法 |
| **668-670** | `getMethod().invoke()` | `Pair` | `Object getValue()` | 尝试通过 getValue() 获取 Pair 的第二个元素（after row） |
| **675-677** | `getMethod().invoke()` | `Pair` | `Object getSecond()` | 尝试通过 getSecond() 获取 Pair 的第二个元素 |
| **682-684** | `getMethod().invoke()` | `Pair` | `Object getRight()` | 尝试通过 getRight() 获取 Pair 的第二个元素 |
| **689-691** | `getDeclaredField().get()` | `Pair` | 字段：`value` | 尝试通过字段访问获取 Pair 的第二个元素 |
| **697-699** | `getDeclaredField().get()` | `Pair` | 字段：`second` | 尝试通过字段访问获取 Pair 的第二个元素 |

---

### 2.2 CanalListener（Canal 监听）

**文件位置**：`common/src/main/java/com/lixiangyu/common/migration/CanalListener.java`

#### 2.2.1 CanalConnector 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **174** | `Class.forName()` | `com.alibaba.otter.canal.client.CanalConnector` | - | 检查 CanalConnector 类是否存在 |
| **225** | `Class.forName()` | `com.alibaba.otter.canal.client.CanalConnectors` | - | 加载 CanalConnectors 工具类 |
| **226-232** | `getMethod().invoke()` | `CanalConnectors` | `static CanalConnector newSingleConnector(InetSocketAddress, String, String, String)` | 创建单机模式的 Canal 连接器 |
| **241** | `getMethod().invoke()` | `CanalConnector` | `void connect()` | 连接到 Canal 服务器 |
| **255** | `getMethod().invoke()` | `CanalConnector` | `void subscribe(String filter)` | 订阅 binlog 变更（指定过滤条件） |
| **267-268** | `getMethod().invoke()` | `CanalConnector` | `Message getWithoutAck(int batchSize)` | 批量获取消息（不立即确认） |
| **560** | `getMethod().invoke()` | `CanalConnector` | `void ack(long batchId)` | 确认消息（表示已成功处理） |
| **567** | `getMethod().invoke()` | `CanalConnector` | `void rollback()` | 回滚消息（表示处理失败） |
| **574** | `getMethod().invoke()` | `CanalConnector` | `void disconnect()` | 断开与 Canal 服务器的连接 |

#### 2.2.2 Canal Message 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **279** | `getMethod().invoke()` | `com.alibaba.otter.canal.protocol.Message` | `long getId()` | 获取消息的批次 ID |
| **280** | `getMethod().invoke()` | `Message` | `List<Entry> getEntries()` | 获取消息中的所有 Entry（binlog 变更条目） |

#### 2.2.3 Canal Entry 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **301** | `getMethod().invoke()` | `com.alibaba.otter.canal.protocol.CanalEntry$Entry` | `EntryType getEntryType()` | 获取 Entry 的类型（ROWDATA、TRANSACTIONBEGIN 等） |
| **302** | `getMethod().invoke()` | `EntryType`（枚举） | `String name()` | 获取枚举常量的名称 |
| **310** | `getMethod().invoke()` | `Entry` | `Header getHeader()` | 获取 Entry 的元数据头信息 |
| **313** | `getMethod().invoke()` | `Header` | `String getSchemaName()` | 获取数据库名 |
| **314** | `getMethod().invoke()` | `Header` | `String getTableName()` | 获取表名 |
| **315** | `getMethod().invoke()` | `Header` | `String getEventType()` | 获取事件类型（INSERT、UPDATE、DELETE） |
| **323** | `getMethod().invoke()` | `Entry` | `byte[] getStoreValue()` | 获取 Entry 的序列化数据（Protobuf 格式） |

#### 2.2.4 Canal RowChange 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **324** | `Class.forName()` | `com.alibaba.otter.canal.protocol.CanalEntry$RowChange` | - | 加载 RowChange 类 |
| **325-326** | `getMethod().invoke()` | `RowChange` | `static RowChange parseFrom(byte[] data)` | 从 Protobuf 字节数组解析 RowChange 对象 |
| **337** | `getMethod().invoke()` | `RowChange` | `List<RowData> getRowDatasList()` | 获取 RowChange 中的所有行数据 |

#### 2.2.5 Canal RowData 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **466** | `getMethod().invoke()` | `com.alibaba.otter.canal.protocol.CanalEntry$RowData` | `List<Column> getAfterColumnsList()` | 获取变更后的列数据列表 |
| **497** | `getMethod().invoke()` | `RowData` | `List<Column> getBeforeColumnsList()` | 获取变更前的列数据列表 |

#### 2.2.6 Canal Column 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **474** | `getMethod().invoke()` | `com.alibaba.otter.canal.protocol.CanalEntry$Column` | `String getName()` | 获取列名 |
| **475** | `getMethod().invoke()` | `Column` | `String getValue()` | 获取列值（字符串格式） |
| **476** | `getMethod().invoke()` | `Column` | `boolean getIsNull()` | 判断列值是否为 NULL |
| **501** | `getMethod().invoke()` | `Column` | `String getName()` | 获取列名（before 列） |
| **502** | `getMethod().invoke()` | `Column` | `String getValue()` | 获取列值（before 列） |
| **503** | `getMethod().invoke()` | `Column` | `boolean getIsNull()` | 判断列值是否为 NULL（before 列） |

---

### 2.3 JpaDatabaseOperator（JPA 数据库操作）

**文件位置**：`common/src/main/java/com/lixiangyu/common/migration/operator/JpaDatabaseOperator.java`

#### 2.3.1 EntityManager 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **83-85** | `getMethod().invoke()` | `javax.persistence.EntityManager` | `Query createNativeQuery(String sqlString)` | 创建原生 SQL 查询对象 |
| **97-99** | `getMethod().invoke()` | `EntityManager` | `void persist(Object entity)` | 持久化实体对象（INSERT 操作） |
| **111-113** | `getMethod().invoke()` | `EntityManager` | `<T> T merge(T entity)` | 合并实体对象（UPDATE 操作） |
| **124-126** | `getMethod().invoke()` | `EntityManager` | `void remove(Object entity)` | 删除实体对象（DELETE 操作） |
| **138-140** | `getMethod().invoke()` | `EntityManager` | `<T> T find(Class<T> entityClass, Object id)` | 根据主键查找实体对象 |
| **151-153** | `getMethod().invoke()` | `EntityManager` | `<T> T unwrap(Class<T> clazz)` | 获取底层对象（如 JDBC Connection） |

#### 2.3.2 EntityManagerFactory 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **178-180** | `getMethod().invoke()` | `javax.persistence.EntityManagerFactory` | `EntityManager createEntityManager()` | 创建新的 EntityManager 实例 |

#### 2.3.3 Query 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **203-205** | `getMethod().invoke()` | `javax.persistence.Query` | `Query setParameter(int position, Object value)` | 为查询设置参数（按位置） |
| **217-219** | `getMethod().invoke()` | `Query` | `int executeUpdate()` | 执行更新或删除 SQL 语句 |
| **230-232** | `getMethod().invoke()` | `Query` | `Object getSingleResult()` | 执行查询并返回单个结果 |

---

### 2.4 MyBatisDatabaseOperator（MyBatis 数据库操作）

**文件位置**：`common/src/main/java/com/lixiangyu/common/migration/operator/MyBatisDatabaseOperator.java`

#### 2.4.1 SqlSessionTemplate 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **83-85** | `getMethod().invoke()` | `org.mybatis.spring.SqlSessionTemplate` | `Connection getConnection()` | 从 SqlSessionTemplate 获取底层 JDBC Connection |
| **97-99** | `getMethod().invoke()` | `SqlSessionTemplate` | `SqlSession getSqlSession()` | 获取内部的 SqlSession 实例 |

#### 2.4.2 SqlSessionFactory 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **124-126** | `getMethod().invoke()` | `org.apache.ibatis.session.SqlSessionFactory` | `SqlSession openSession()` | 创建新的 SqlSession 实例 |

#### 2.4.3 SqlSession 相关反射

| 行号 | 反射调用 | 类名 | 方法原型 | 作用说明 |
|------|---------|------|---------|---------|
| **151-153** | `getMethod().invoke()` | `org.apache.ibatis.session.SqlSession` | `<E> List<E> selectList(String statement, Object parameter)` | 执行查询语句并返回结果列表 |
| **166-168** | `getMethod().invoke()` | `SqlSession` | `int update(String statement, Object parameter)` | 执行更新、插入或删除语句 |

---

## 三、反射调用的详细说明

### 3.1 Class.forName() - 动态加载类

**方法原型**：
```java
static Class<?> Class.forName(String className) throws ClassNotFoundException
```

**作用**：
- 根据类名动态加载类
- 如果类不存在，抛出 `ClassNotFoundException`

**使用场景**：
- 检查第三方库是否存在
- 动态加载类以便后续使用反射调用

**示例**：
```java
// 检查 BinaryLogClient 类是否存在
Class.forName("com.github.shyiko.mysql.binlog.BinaryLogClient");
```

---

### 3.2 getConstructor().newInstance() - 创建实例

**方法原型**：
```java
Constructor<T> Class.getConstructor(Class<?>... parameterTypes)
T Constructor.newInstance(Object... initargs)
```

**作用**：
- 获取类的构造函数
- 使用构造函数创建实例

**使用场景**：
- 创建第三方库的对象实例

**示例**：
```java
// 创建 BinaryLogClient 实例
Class<?> clazz = Class.forName("com.github.shyiko.mysql.binlog.BinaryLogClient");
Object client = clazz.getConstructor(String.class, int.class)
    .newInstance(host, port);
```

---

### 3.3 getMethod().invoke() - 调用方法

**方法原型**：
```java
Method Class.getMethod(String name, Class<?>... parameterTypes)
Object Method.invoke(Object obj, Object... args)
```

**作用**：
- 获取类的公共方法
- 通过反射调用方法

**使用场景**：
- 调用第三方库的方法
- 避免编译期依赖

**示例**：
```java
// 调用 setUsername 方法
client.getClass()
    .getMethod("setUsername", String.class)
    .invoke(client, username);
```

---

### 3.4 Proxy.newProxyInstance() - 创建动态代理

**方法原型**：
```java
static Object Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
```

**作用**：
- 动态创建接口的实现类
- 通过 `InvocationHandler` 处理接口方法调用

**使用场景**：
- 实现接口但避免直接依赖接口类
- 将方法调用转发到自定义处理逻辑

**示例**：
```java
// 创建 EventListener 的动态代理
Object listener = Proxy.newProxyInstance(
    eventListenerClass.getClassLoader(),
    new Class[]{eventListenerClass},
    (proxy, method, args) -> {
        if ("onEvent".equals(method.getName())) {
            handleBinlogEvent(args[0]);
        }
        return null;
    });
```

---

### 3.5 getDeclaredField().get() - 访问字段

**方法原型**：
```java
Field Class.getDeclaredField(String name)
void Field.setAccessible(boolean flag)
Object Field.get(Object obj)
```

**作用**：
- 获取类的字段（包括私有字段）
- 设置字段可访问
- 获取字段值

**使用场景**：
- 访问对象的私有字段
- 某些实现可能使用字段而不是方法

**示例**：
```java
// 通过字段访问获取 Pair 的第一个元素
Field field = pair.getClass().getDeclaredField("key");
field.setAccessible(true);
Object value = field.get(pair);
```

---

## 四、反射调用的异常处理

### 4.1 统一异常处理

所有反射调用都使用统一的异常处理模式：

```java
try {
    // 反射调用
    Object result = target.getClass()
        .getMethod("methodName", ParameterType.class)
        .invoke(target, parameter);
} catch (Exception e) {
    // 统一转换为 RuntimeException
    throw new RuntimeException("操作失败", e);
}
```

### 4.2 异常类型

反射调用可能抛出的异常：

| 异常类型 | 说明 | 处理方式 |
|---------|------|---------|
| `ClassNotFoundException` | 类不存在 | 降级处理或抛出运行时异常 |
| `NoSuchMethodException` | 方法不存在 | 尝试其他方法或抛出运行时异常 |
| `IllegalAccessException` | 方法不可访问 | 设置可访问或抛出运行时异常 |
| `InvocationTargetException` | 方法调用异常 | 获取原始异常并抛出 |
| `NoSuchFieldException` | 字段不存在 | 尝试其他字段或忽略 |

---

## 五、反射调用的最佳实践

### 5.1 添加详细注释

每个反射调用都应该有详细注释，包括：
- 类名和完整包路径
- 方法原型（参数类型和返回类型）
- 方法的具体作用
- 使用场景说明
- 代码位置（行号）

### 5.2 提供降级方案

如果反射调用失败，应该提供降级方案：

```java
try {
    // 尝试使用反射调用
    Class.forName("com.example.Class");
    // 使用反射功能
} catch (ClassNotFoundException e) {
    // 降级方案：使用其他实现
    log.warn("反射库未找到，使用降级方案");
    fallbackImplementation();
}
```

### 5.3 缓存反射结果

对于频繁使用的反射调用，可以缓存结果：

```java
// 缓存方法对象
private static Method cachedMethod;

if (cachedMethod == null) {
    cachedMethod = target.getClass().getMethod("methodName");
}
cachedMethod.invoke(target);
```

### 5.4 类型安全

虽然使用 `Object` 类型接收反射结果，但应该：
- 在包装类中提供类型安全的接口
- 使用泛型限制返回类型
- 添加类型转换和验证

---

## 六、反射调用的性能考虑

### 6.1 性能影响

反射调用比直接调用慢，因为：
- 需要查找类、方法、字段
- 需要参数类型匹配
- 需要安全检查

### 6.2 优化建议

1. **缓存反射结果**：缓存 `Method`、`Field`、`Constructor` 对象
2. **减少反射调用**：在初始化时完成反射，运行时直接使用
3. **使用包装类**：将反射调用封装在包装类中，提供类型安全接口

---

## 七、总结

### 7.1 反射使用统计

| 文件 | 反射调用次数 | 主要用途 |
|------|------------|---------|
| **BinlogListener.java** | 20+ | MySQL binlog 监听 |
| **CanalListener.java** | 25+ | Canal binlog 监听 |
| **JpaDatabaseOperator.java** | 9 | JPA 数据库操作 |
| **MyBatisDatabaseOperator.java** | 5 | MyBatis 数据库操作 |
| **总计** | **59+** | - |

### 7.2 核心优势

✅ **编译期无依赖**：`common` 模块可以在没有第三方库的情况下编译  
✅ **运行时按需加载**：根据实际环境选择使用哪些库  
✅ **降级方案**：库不存在时可以使用降级实现  
✅ **类型安全**：通过包装类提供类型安全的接口  

### 7.3 注意事项

⚠️ **性能影响**：反射调用比直接调用慢，但影响可接受  
⚠️ **异常处理**：需要完善的异常处理和降级方案  
⚠️ **代码可读性**：反射调用需要详细注释，提高可维护性  

---

**文档版本**: 1.0  
**最后更新**: 2025-12-29

