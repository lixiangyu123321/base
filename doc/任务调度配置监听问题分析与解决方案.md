# 任务调度配置监听问题分析与解决方案

## 文档信息

- **创建日期**: 2025-12-29
- **问题类型**: Nacos 配置中心监听失效
- **影响范围**: 任务调度框架配置热更新功能

---

## 问题概述

任务调度框架无法监听 Nacos 配置中心中任务配置的变更，导致配置变更后无法实时更新到数据库和调度器。

### 问题表现

1. 在 Nacos 控制台修改任务配置（如 `scheduler.job.exampleJob.EXAMPLE.dev.json`）
2. 应用无法收到配置变更通知
3. 数据库中的任务配置不会自动更新
4. 调度器状态不会自动变更

---

## 问题原因分析

### 根本原因

`DynamicConfigManager.addListener()` 方法将所有监听器都注册到主 Data ID（如 `demo-dev.json`），而任务配置使用的是独立的 Data ID（如 `scheduler.job.exampleJob.EXAMPLE.dev.json`），导致监听器注册到错误的 Data ID。

### 详细分析

#### 1. 任务配置的 Data ID 格式

任务配置使用独立的 Data ID，格式为：
```
scheduler.job.{jobName}.{jobGroup}.{environment}.json
```

例如：
```
scheduler.job.exampleJob.EXAMPLE.dev.json
```

#### 2. 原有监听器注册流程

```
JobConfigChangeListener.registerJobConfigListener()
  ↓
构建 Data ID: scheduler.job.exampleJob.EXAMPLE.dev.json
  ↓
调用 configManager.addListener(dataId, listener)
  ↓
DynamicConfigManager.addListener() 
  ↓
注册到 mainDataId (demo-dev.json) ❌ 错误！
  ↓
结果：监听器监听的是错误的 Data ID
```

#### 3. 代码问题定位

**问题代码** (`DynamicConfigManager.java` 第 334 行)：

```java
public void addListener(String key, ConfigChangeListener listener) {
    // ...
    // 问题：无论传入什么 key，都注册到 mainDataId
    configService.addListener(mainDataId, group, nacosListener);
    // ...
}
```

**调用代码** (`JobConfigChangeListener.java` 第 64 行)：

```java
public void registerJobConfigListener(JobConfig config) {
    String dataId = buildNacosDataId(config);
    // dataId = "scheduler.job.exampleJob.EXAMPLE.dev.json"
    
    // 问题：传入的 dataId 被当作 key，但实际监听的是 mainDataId
    configManager.addListener(dataId, (key, newValue) -> {
        handleConfigChange(key, newValue);
    });
}
```

#### 4. 监听器类型不匹配

原有实现假设所有配置都在主 Data ID 中，通过 key 来区分不同的配置项。但任务配置是独立的 Data ID，需要监听整个 Data ID 的变更，而不是某个 key 的变更。

---

## 解决方案

### 方案概述

扩展 `DynamicConfigManager` 的监听功能，支持监听不同的 Data ID，并区分两种监听模式：
1. **Key 监听模式**：监听主 Data ID 中某个 key 的变更（原有功能）
2. **Data ID 监听模式**：监听整个独立 Data ID 的变更（新增功能）

### 详细实现

#### 1. 扩展 `DynamicConfigManager.addListener` 方法

**文件**: `common/src/main/java/com/lixiangyu/common/config/DynamicConfigManager.java`

**修改内容**：

```java
/**
 * 注册配置变更监听器（使用主 Data ID）
 *
 * @param key 配置键
 * @param listener 监听器
 */
public void addListener(String key, ConfigChangeListener listener) {
    addListener(key, null, listener);
}

/**
 * 注册配置变更监听器（支持指定 Data ID）
 *
 * @param key 配置键（用于标识监听器，可以是配置键或 Data ID）
 * @param dataId 要监听的 Data ID（如果为 null，则使用主 Data ID）
 * @param listener 监听器
 */
public void addListener(String key, String dataId, ConfigChangeListener listener) {
    // 添加到监听器列表
    listeners.computeIfAbsent(key, k -> new ArrayList<>()).add(listener);
    
    // 如果启用 Nacos，注册 Nacos 监听器
    if (nacosEnabled && configService != null) {
        try {
            // 确定要监听的 Data ID
            String targetDataId = StringUtils.hasText(dataId) ? dataId : mainDataId;
            
            // 创建 Nacos 监听器适配器
            Listener nacosListener;
            if (StringUtils.hasText(dataId)) {
                // 监听整个 Data ID 的变更，传入完整的配置内容
                nacosListener = new NacosDataIdListenerAdapter(key, dataId, listener);
            } else {
                // 监听主 Data ID 中某个 key 的变更
                nacosListener = new NacosListenerAdapter(key, listener);
            }
            
            configService.addListener(targetDataId, group, nacosListener);
            nacosListeners.put(key, nacosListener);
            // 记录监听器对应的 Data ID，用于销毁时正确移除
            listenerDataIdMap.put(key, targetDataId);
            log.info("注册配置变更监听器成功，Key: {}, Data ID: {}", key, targetDataId);
        } catch (NacosException e) {
            log.error("注册 Nacos 配置变更监听器失败，Key: {}, Data ID: {}", key, dataId, e);
        }
    }
}
```

#### 2. 创建 `NacosDataIdListenerAdapter` 类

用于监听整个 Data ID 的变更：

```java
/**
 * Nacos Data ID 监听器适配器
 * 用于监听整个 Data ID 的变更（如任务配置的独立 Data ID）
 * 当 Data ID 的整个内容变更时，将整个配置内容传递给监听器
 */
private class NacosDataIdListenerAdapter implements Listener {
    private final String key;
    private final String dataId;
    private final ConfigChangeListener listener;

    public NacosDataIdListenerAdapter(String key, String dataId, ConfigChangeListener listener) {
        this.key = key;
        this.dataId = dataId;
        this.listener = listener;
    }

    @Override
    public void receiveConfigInfo(String configInfo) {
        try {
            // 对于独立的 Data ID，直接传递整个配置内容
            if (StringUtils.hasText(configInfo)) {
                // 通知监听器，key 是 Data ID，newValue 是整个配置内容
                listener.onChange(key, configInfo);
                
                log.info("Nacos Data ID 配置变更通知，Data ID: {}, Key: {}", dataId, key);
            }
        } catch (Exception e) {
            log.error("处理 Nacos Data ID 配置变更通知失败，Data ID: {}, Key: {}", dataId, key, e);
        }
    }

    @Override
    public Executor getExecutor() {
        return null; // 使用默认执行器
    }
}
```

#### 3. 修复 `JobConfigChangeListener.registerJobConfigListener`

**文件**: `common/src/main/java/com/lixiangyu/common/scheduler/core/JobConfigChangeListener.java`

**修改内容**：

```java
public void registerJobConfigListener(JobConfig config) {
    String dataId = buildNacosDataId(config);
    
    // 检查是否已注册
    if (registeredListeners.containsKey(dataId)) {
        log.debug("任务配置监听器已注册，Data ID: {}", dataId);
        return;
    }
    
    // 注册监听器（指定 Data ID，监听整个 Data ID 的变更）
    // 注意：这里传入 dataId 作为 key，同时指定 dataId 参数，表示监听整个 Data ID 的变更
    configManager.addListener(dataId, dataId, (key, newValue) -> {
        try {
            // key 是 Data ID，newValue 是整个配置内容（JSON 字符串）
            handleConfigChange(key, newValue);
        } catch (Exception e) {
            log.error("处理配置变更失败，Key: {}", key, e);
        }
    });
    
    registeredListeners.put(dataId, true);
    log.info("注册任务配置监听器成功，Data ID: {}, Job Name: {}", dataId, config.getJobName());
}
```

#### 4. 添加监听器 Data ID 映射

为了在销毁时正确移除监听器，添加了映射关系：

```java
/**
 * 存储监听器信息（Key -> Data ID 的映射）
 * 用于销毁时正确移除监听器
 */
private final Map<String, String> listenerDataIdMap = new ConcurrentHashMap<>();
```

#### 5. 修复 `removeListener` 方法

支持指定 Data ID 的移除：

```java
/**
 * 移除配置变更监听器（支持指定 Data ID）
 *
 * @param key 配置键
 * @param dataId 要移除监听的 Data ID（如果为 null，则使用主 Data ID）
 */
public void removeListener(String key, String dataId) {
    // 移除本地监听器
    listeners.remove(key);
    
    // 移除 Nacos 监听器
    if (nacosEnabled && configService != null) {
        Listener nacosListener = nacosListeners.remove(key);
        if (nacosListener != null) {
            try {
                // 优先使用传入的 dataId，否则从映射中获取，最后使用主 Data ID
                String targetDataId = StringUtils.hasText(dataId) 
                        ? dataId 
                        : listenerDataIdMap.getOrDefault(key, mainDataId);
                configService.removeListener(targetDataId, group, nacosListener);
                listenerDataIdMap.remove(key);
                log.info("移除配置变更监听器成功，Key: {}, Data ID: {}", key, targetDataId);
            } catch (Exception e) {
                log.error("移除 Nacos 配置变更监听器失败，Key: {}, Data ID: {}", key, dataId, e);
            }
        }
    }
}
```

---

## 修复后的流程

### 正确的监听流程

```
JobConfigChangeListener.registerJobConfigListener()
  ↓
构建 Data ID: scheduler.job.exampleJob.EXAMPLE.dev.json
  ↓
调用 configManager.addListener(dataId, dataId, listener) ✅
  ↓
DynamicConfigManager.addListener() 
  ↓
判断：dataId 不为 null，使用 NacosDataIdListenerAdapter
  ↓
注册到指定的 dataId (scheduler.job.exampleJob.EXAMPLE.dev.json) ✅
  ↓
结果：监听器正确监听任务配置的 Data ID
  ↓
Nacos 配置变更时，收到整个配置内容（JSON 字符串）
  ↓
自动更新数据库和调度器 ✅
```

### 两种监听模式对比

| 监听模式 | 使用场景 | Data ID | 监听内容 | 适配器 |
|---------|---------|---------|---------|--------|
| **Key 监听模式** | 主配置中的某个 key | `mainDataId` (如 `demo-dev.json`) | 配置中的某个 key 的值 | `NacosListenerAdapter` |
| **Data ID 监听模式** | 独立的配置 Data ID | 独立的 Data ID (如 `scheduler.job.xxx.json`) | 整个 Data ID 的配置内容 | `NacosDataIdListenerAdapter` |

---

## 使用说明

### 1. 在 Nacos 中创建任务配置

1. 登录 Nacos 控制台：`http://localhost:8848/nacos`
2. 进入"配置管理" -> "配置列表"
3. 点击"+"创建新配置：
   - **Data ID**: `scheduler.job.exampleJob.EXAMPLE.dev.json`
   - **Group**: `DEFAULT_GROUP`
   - **配置格式**: `JSON`
   - **配置内容**:
   ```json
   {
     "jobName": "exampleJob",
     "jobGroup": "EXAMPLE",
     "jobType": "QUARTZ",
     "jobClass": "com.lixiangyu.common.scheduler.example.ExampleJob",
     "cronExpression": "0 0/5 * * * ?",
     "description": "示例任务：演示自动注册功能",
     "status": "RUNNING",
     "environment": "dev",
     "retryCount": 3,
     "retryInterval": 60,
     "alertEnabled": true,
     "grayReleaseEnabled": false,
     "version": 1
   }
   ```

### 2. 验证配置监听

1. **启动应用**：应用启动时会自动注册任务并监听配置
2. **查看日志**：应该能看到以下日志：
   ```
   注册任务配置监听器成功，Data ID: scheduler.job.exampleJob.EXAMPLE.dev.json, Job Name: exampleJob
   ```

3. **修改配置**：在 Nacos 控制台修改配置内容（如修改 `cronExpression` 或 `status`）
4. **查看变更日志**：应该能看到以下日志：
   ```
   Nacos Data ID 配置变更通知，Data ID: scheduler.job.exampleJob.EXAMPLE.dev.json, Key: scheduler.job.exampleJob.EXAMPLE.dev.json
   检测到任务配置变更，Key: scheduler.job.exampleJob.EXAMPLE.dev.json
   任务配置更新成功，Job Name: exampleJob, Group: EXAMPLE
   ```

### 3. 配置变更自动处理

当 Nacos 中的任务配置变更时，系统会自动：

1. **更新数据库**：将 Nacos 中的配置同步到数据库
2. **更新调度器**：
   - 如果 `status` 变更为 `RUNNING`，自动启动任务
   - 如果 `status` 变更为 `STOPPED`，自动停止任务
   - 如果 `status` 变更为 `PAUSED`，自动暂停任务
3. **更新 Cron 表达式**：如果 `cronExpression` 变更，自动更新调度时间

---

## 技术要点

### 1. 监听器注册时机

任务配置监听器在任务自动注册时自动注册：

```java
// JobAutoRegister.registerJob()
JobConfig savedConfig = saveOrUpdateConfig(config);
publishConfigToNacos(savedConfig);
registerConfigListener(savedConfig); // 注册监听器
```

### 2. Data ID 命名规范

任务配置的 Data ID 格式：
```
scheduler.job.{jobName}.{jobGroup}.{environment}.json
```

**注意事项**：
- `jobName`、`jobGroup`、`environment` 中不能包含点号（`.`）
- 如果包含点号，会导致 `parseConfigKey` 解析失败

### 3. 配置内容格式

任务配置必须是有效的 JSON 格式，包含以下字段：

| 字段 | 类型 | 必填 | 说明 |
|-----|------|------|------|
| `jobName` | String | 是 | 任务名称 |
| `jobGroup` | String | 是 | 任务分组 |
| `jobType` | String | 是 | 任务类型：QUARTZ/XXL_JOB |
| `jobClass` | String | 是 | 任务执行类全限定名 |
| `cronExpression` | String | 否 | Cron 表达式 |
| `status` | String | 是 | 任务状态：RUNNING/STOPPED/PAUSED |
| `environment` | String | 是 | 环境：dev/test/prod |
| `retryCount` | Integer | 否 | 重试次数（默认 3） |
| `retryInterval` | Integer | 否 | 重试间隔（秒，默认 60） |
| `alertEnabled` | Boolean | 否 | 是否启用告警（默认 true） |

### 4. 监听器生命周期

- **注册时机**：任务自动注册时
- **移除时机**：应用关闭时（`@PreDestroy`）
- **持久化**：监听器信息存储在内存中，应用重启后需要重新注册

---

## 常见问题

### Q1: 为什么监听器注册后没有收到变更通知？

**可能原因**：
1. Nacos 配置的 Data ID 格式不正确
2. Nacos 配置的 Group 不正确（应该是 `DEFAULT_GROUP`）
3. Nacos 配置中心未启用或连接失败

**解决方法**：
1. 检查日志中是否有"注册任务配置监听器成功"的日志
2. 检查 Nacos 控制台中的配置 Data ID 和 Group 是否正确
3. 检查 `application.yml` 中的 Nacos 配置是否正确

### Q2: 配置变更后数据库没有更新？

**可能原因**：
1. 配置内容格式不正确（不是有效的 JSON）
2. 配置中缺少必填字段
3. 数据库中没有对应的任务配置记录

**解决方法**：
1. 检查 Nacos 配置内容是否为有效的 JSON
2. 检查配置中是否包含所有必填字段
3. 查看日志中的错误信息

### Q3: 如何手动触发配置变更？

可以通过以下方式手动触发：
1. 在 Nacos 控制台修改配置并发布
2. 通过 API 调用 `DynamicConfigManager.publishConfig()` 方法
3. 通过 `SchedulerController` 的接口更新配置

---

## 总结

### 修复内容

1. ✅ 扩展 `DynamicConfigManager.addListener` 方法，支持指定 Data ID
2. ✅ 创建 `NacosDataIdListenerAdapter` 类，支持监听整个 Data ID 的变更
3. ✅ 修复 `JobConfigChangeListener.registerJobConfigListener`，正确注册监听器
4. ✅ 添加监听器 Data ID 映射，支持正确移除监听器

### 修复效果

- ✅ 任务配置监听器能正确监听独立的 Data ID
- ✅ Nacos 配置变更时能实时收到通知
- ✅ 配置变更后自动更新数据库
- ✅ 配置变更后自动更新调度器状态

### 注意事项

1. **Data ID 格式**：必须严格按照 `scheduler.job.{jobName}.{jobGroup}.{environment}.json` 格式
2. **配置内容**：必须是有效的 JSON 格式，包含所有必填字段
3. **监听器注册**：监听器在任务自动注册时自动注册，无需手动注册
4. **配置优先级**：Nacos 配置 > 数据库配置 > 注解配置

---

## 相关文件

- `common/src/main/java/com/lixiangyu/common/config/DynamicConfigManager.java`
- `common/src/main/java/com/lixiangyu/common/scheduler/core/JobConfigChangeListener.java`
- `common/src/main/java/com/lixiangyu/common/scheduler/core/JobAutoRegister.java`

---

## 附录：配置更新 SQL 问题修复

### 问题描述

在配置变更监听后，执行更新 SQL 时返回 0 行，导致配置更新失败。

**错误日志**：
```
DEBUG c.l.d.m.J.updateByPrimaryKeySelective - <==    Updates: 0
INFO  c.l.c.scheduler.service.impl.JobConfigServiceImpl - 更新任务配置成功，Job ID: 1, Name: exampleJob
```

### 问题原因

1. **乐观锁机制**：`updateByPrimaryKeySelective` 方法使用乐观锁，WHERE 条件包含所有字段
2. **配置对象状态不一致**：在 `updateConfigFromNacos` 中直接修改了从数据库查询的配置对象，但该对象的 `updateTime` 等字段是查询时的旧值
3. **WHERE 条件不匹配**：更新时设置了新的 `updateTime`，但 WHERE 条件使用的是旧的 `updateTime`，导致条件不匹配

### 解决方案

在 `updateConfigFromNacos` 方法中，**重新查询数据库获取最新配置**，确保乐观锁的 WHERE 条件正确：

```java
private void updateConfigFromNacos(JobConfig config, JSONObject configJson) {
    // 重要：重新查询数据库获取最新配置，确保乐观锁的 WHERE 条件正确
    JobConfig latestConfig = jobConfigService.getById(config.getId());
    if (latestConfig == null) {
        log.warn("数据库中没有找到配置，ID: {}", config.getId());
        return;
    }
    
    // 更新字段...
    latestConfig.setCronExpression(configJson.getString("cronExpression"));
    // ...
    
    // 保存到数据库（使用最新查询的配置，确保乐观锁正确）
    jobConfigService.update(latestConfig);
}
```

### 修复效果

- ✅ 更新 SQL 能正确匹配 WHERE 条件
- ✅ 配置更新成功，返回正确的更新行数
- ✅ 乐观锁机制正常工作

### 补充：selectByPrimaryKey SQL 问题修复

> **详细说明**：关于 tk.mybatis 乐观锁问题的详细解释，请参考 [tk.mybatis 乐观锁问题详解](./tk.mybatis乐观锁问题详解.md)

#### 问题描述

`selectByPrimaryKey` 的 SQL 语句包含了所有字段的 WHERE 条件，且参数都是 `1(Long)`，导致查询失败。

**错误日志**：
```
DEBUG c.l.dal.mapper.JobConfigMapper.selectByPrimaryKey - ==>  Preparing: SELECT ... WHERE id = ? AND job_name = ? AND job_group = ? ... AND update_time = ?
DEBUG c.l.dal.mapper.JobConfigMapper.selectByPrimaryKey - ==> Parameters: 1(Long), 1(Long), 1(Long), ..., 1(Long)
DEBUG c.l.dal.mapper.JobConfigMapper.selectByPrimaryKey - <==      Total: 0
```

#### 问题原因

1. **tk.mybatis 乐观锁机制**：当实体类有 `version` 字段时，`selectByPrimaryKey` 方法可能会使用乐观锁，WHERE 条件包含所有字段
2. **参数绑定错误**：由于 WHERE 条件包含所有字段，但只传入了一个 ID 参数，导致参数绑定错误，所有参数都被设置为 `1(Long)`

#### 解决方案

**创建自定义的 `selectById` 方法**，避免使用 tk.mybatis 的 `selectByPrimaryKey` 方法：

**1. 在 Mapper 接口中添加方法**：

```java
/**
 * 根据主键ID查询（不使用乐观锁）
 *
 * @param id 主键ID
 * @return 任务配置
 */
JobConfig selectById(@Param("id") Long id);
```

**2. 在 Mapper XML 中添加 SQL**：

```xml
<!-- 根据主键ID查询（不使用乐观锁） -->
<select id="selectById" resultMap="BaseResultMap">
    SELECT * FROM scheduler_job_config
    WHERE id = #{id}
</select>
```

**3. 修改 Service 实现**：

```java
@Override
public JobConfig getById(Long id) {
    // 使用自定义的 selectById 方法，避免 tk.mybatis 的乐观锁问题
    return jobConfigMapper.selectById(id);
}
```

#### 修复效果

- ✅ `selectById` 只根据主键 ID 查询，WHERE 条件正确
- ✅ 参数绑定正确，查询成功
- ✅ 避免了 tk.mybatis 乐观锁机制的影响

### 补充：updateByPrimaryKeySelective SQL 问题修复

> **详细说明**：关于 tk.mybatis 乐观锁问题的详细解释，请参考 [tk.mybatis 乐观锁问题详解](./tk.mybatis乐观锁问题详解.md)

#### 问题描述

`updateByPrimaryKeySelective` 的 SQL 语句包含了所有字段的 WHERE 条件，导致更新失败。

**错误日志**：
```
DEBUG c.l.d.m.J.updateByPrimaryKeySelective - ==>  Preparing: UPDATE ... SET ... WHERE id = ? AND job_name = ? ... AND update_time = ?
DEBUG c.l.d.m.J.updateByPrimaryKeySelective - <==    Updates: 0
```

#### 问题原因

与 `selectByPrimaryKey` 相同，tk.mybatis 的乐观锁机制导致 WHERE 条件包含所有字段，但实际只需要根据主键 ID 更新。

#### 解决方案

**创建自定义的 `updateByIdSelective` 方法**，只根据主键 ID 更新：

**1. 在 Mapper 接口中添加方法**：

```java
/**
 * 根据主键ID更新（不使用乐观锁，只更新非空字段）
 *
 * @param config 任务配置
 * @return 更新的记录数
 */
int updateByIdSelective(JobConfig config);
```

**2. 在 Mapper XML 中添加 SQL**：

```xml
<!-- 根据主键ID更新（不使用乐观锁，只更新非空字段） -->
<update id="updateByIdSelective">
    UPDATE scheduler_job_config
    <set>
        <if test="jobName != null">job_name = #{jobName},</if>
        <if test="jobGroup != null">job_group = #{jobGroup},</if>
        <!-- ... 其他字段 ... -->
        <if test="updateTime != null">update_time = #{updateTime},</if>
    </set>
    WHERE id = #{id}
</update>
```

**3. 修改 Service 实现**：

```java
@Override
@Transactional(rollbackFor = Exception.class)
public JobConfig update(JobConfig config) {
    config.setUpdateTime(new Date());
    if (config.getVersion() != null) {
        config.setVersion(config.getVersion() + 1);
    } else {
        JobConfig existing = jobConfigMapper.selectById(config.getId());
        if (existing != null) {
            config.setVersion(existing.getVersion() + 1);
        }
    }
    // 使用自定义的 updateByIdSelective 方法，避免 tk.mybatis 的乐观锁问题
    int updated = jobConfigMapper.updateByIdSelective(config);
    if (updated == 0) {
        log.warn("更新任务配置失败，未找到对应记录，Job ID: {}", config.getId());
    }
    return config;
}
```

**4. 修复所有使用 `updateByPrimaryKeySelective` 的方法**：

- `enable()` - 启用任务
- `disable()` - 禁用任务
- `pause()` - 暂停任务
- `resume()` - 恢复任务

#### 修复效果

- ✅ `updateByIdSelective` 只根据主键 ID 更新，WHERE 条件正确
- ✅ 更新成功，返回正确的更新行数
- ✅ 避免了 tk.mybatis 乐观锁机制的影响
- ✅ 所有更新操作都能正常工作

---

**文档版本**: 1.3  
**最后更新**: 2025-12-29

