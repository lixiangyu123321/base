# 数据库热迁移工具使用指南

## 文档信息

- **创建日期**: 2025-01-27
- **功能模块**: `com.lixiangyu.common.migration`
- **核心类**: `DataMigrationService`
- **基于**: DTS（数据传输服务）功能设计

---

## 一、功能概述

### 1.1 核心能力

基于 DTS（数据传输服务）的设计理念，实现了通用的数据库热迁移工具，支持：

1. **数据迁移**：将数据从一个数据源迁移至另一个数据源
   - 支持同构数据库（MySQL → MySQL）
   - 支持异构数据库（MySQL → PostgreSQL）
   - 业务不停服，停机时间降至分钟级

2. **数据同步**：在不同数据源之间建立实时、持续的数据同步链路
   - 支持单向或双向同步
   - 构建高可用或高性能的数据架构

3. **数据校验**：对比源端和目标端的数据，验证数据一致性
   - 记录数校验
   - 数据内容校验
   - 不一致记录详情

4. **数据加工**：在数据流动过程中进行实时 ETL 处理
   - 数据清洗
   - 格式转换
   - 字段映射

### 1.2 设计特点

- **通用性**：支持多种数据库类型
- **高性能**：支持并发迁移、批量处理
- **可靠性**：完善的异常处理和日志记录
- **易用性**：提供注解和编程两种使用方式

---

## 二、核心类说明

### 2.1 DataMigrationService（数据迁移服务）

**功能**：执行数据迁移的核心服务类

**主要方法**：
- `migrate(MigrationConfig config)` - 执行数据迁移

**使用示例**：
```java
@Autowired
private DataMigrationService migrationService;

public void migrateData() {
    MigrationConfig config = MigrationConfig.builder()
            .source(MigrationConfig.DataSourceConfig.builder()
                    .url("jdbc:mysql://localhost:3307/source_db")
                    .username("root")
                    .password("123456")
                    .driverClassName("com.mysql.cj.jdbc.Driver")
                    .build())
            .target(MigrationConfig.DataSourceConfig.builder()
                    .url("jdbc:mysql://localhost:3308/target_db")
                    .username("root")
                    .password("123456")
                    .driverClassName("com.mysql.cj.jdbc.Driver")
                    .build())
            .tables(Arrays.asList("user", "order"))
            .enableValidation(true)
            .batchSize(1000)
            .threadCount(4)
            .build();
    
    MigrationResult result = migrationService.migrate(config);
    log.info("迁移完成，状态: {}", result.getStatus());
}
```

### 2.2 MigrationConfig（迁移配置）

**功能**：配置数据迁移的参数

**主要属性**：
- `source` - 源数据源配置
- `target` - 目标数据源配置
- `tables` - 要迁移的表列表（为空则迁移所有表）
- `enableValidation` - 是否启用数据校验
- `enableIncremental` - 是否启用增量同步
- `batchSize` - 批量大小（默认 1000）
- `threadCount` - 并发线程数（默认 4）
- `truncateTarget` - 是否在迁移前清空目标表
- `mode` - 迁移模式（FULL/INCREMENTAL/MIXED）

### 2.3 MigrationResult（迁移结果）

**功能**：返回数据迁移的详细结果

**主要属性**：
- `taskId` - 任务ID
- `status` - 迁移状态
- `totalTables` - 总表数
- `successTables` - 成功表数
- `failedTables` - 失败表数
- `totalRecords` - 总记录数
- `successRecords` - 成功记录数
- `failedRecords` - 失败记录数
- `tableDetails` - 每个表的迁移详情
- `validationResult` - 数据校验结果

### 2.4 DataValidator（数据校验器）

**功能**：验证源端和目标端数据的一致性

**主要方法**：
- `validateTable()` - 校验单个表的数据一致性

### 2.5 @HotMigration（热迁移注解）

**功能**：通过注解方式触发数据迁移

**使用示例**：
```java
@HotMigration(
    source = "sourceDataSource",
    target = "targetDataSource",
    tables = {"user", "order"},
    enableValidation = true
)
public void migrateUserData() {
    // 业务逻辑
}
```

---

## 三、使用方式

### 方式一：编程式使用（推荐）

**步骤 1**：注入服务

```java
@Service
@RequiredArgsConstructor
public class MigrationService {
    
    private final DataMigrationService migrationService;
    
    public void executeMigration() {
        // 构建配置并执行迁移
    }
}
```

**步骤 2**：构建配置

```java
MigrationConfig config = MigrationConfig.builder()
        .source(MigrationConfig.DataSourceConfig.builder()
                .dataSource(sourceDataSource)  // 使用 Spring 管理的 DataSource
                .build())
        .target(MigrationConfig.DataSourceConfig.builder()
                .dataSource(targetDataSource)
                .build())
        .tables(Arrays.asList("user", "order", "product"))
        .enableValidation(true)
        .batchSize(2000)
        .threadCount(8)
        .mode(MigrationConfig.MigrationMode.FULL)
        .build();
```

**步骤 3**：执行迁移

```java
MigrationResult result = migrationService.migrate(config);

// 检查结果
if (result.getStatus() == MigrationResult.MigrationStatus.SUCCESS) {
    log.info("迁移成功，共迁移 {} 条记录", result.getSuccessRecords());
} else {
    log.error("迁移失败: {}", result.getErrorMessage());
}
```

### 方式二：使用 DataSource Bean

**配置多个数据源**：

```java
@Configuration
public class DataSourceConfig {
    
    @Bean("sourceDataSource")
    public DataSource sourceDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3307/source_db");
        config.setUsername("root");
        config.setPassword("123456");
        return new HikariDataSource(config);
    }
    
    @Bean("targetDataSource")
    public DataSource targetDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3308/target_db");
        config.setUsername("root");
        config.setPassword("123456");
        return new HikariDataSource(config);
    }
}
```

**使用 Bean**：

```java
MigrationConfig config = MigrationConfig.builder()
        .source(MigrationConfig.DataSourceConfig.builder()
                .dataSource(sourceDataSource)  // 注入的 Bean
                .build())
        .target(MigrationConfig.DataSourceConfig.builder()
                .dataSource(targetDataSource)
                .build())
        .build();
```

### 方式三：使用 JDBC 连接信息

```java
MigrationConfig config = MigrationConfig.builder()
        .source(MigrationConfig.DataSourceConfig.builder()
                .url("jdbc:mysql://localhost:3307/source_db")
                .username("root")
                .password("123456")
                .driverClassName("com.mysql.cj.jdbc.Driver")
                .build())
        .target(MigrationConfig.DataSourceConfig.builder()
                .url("jdbc:mysql://localhost:3308/target_db")
                .username("root")
                .password("123456")
                .driverClassName("com.mysql.cj.jdbc.Driver")
                .build())
        .build();
```

---

## 四、完整示例

### 4.1 基础迁移示例

```java
package com.lixiangyu.service;

import com.lixiangyu.common.migration.DataMigrationService;
import com.lixiangyu.common.migration.MigrationConfig;
import com.lixiangyu.common.migration.MigrationResult;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Arrays;

@Slf4j
@Service
@RequiredArgsConstructor
public class DatabaseMigrationService {
    
    private final DataMigrationService migrationService;
    
    /**
     * 执行数据库迁移
     */
    public MigrationResult migrateDatabase() {
        // 构建迁移配置
        MigrationConfig config = MigrationConfig.builder()
                // 源数据源（旧数据库）
                .source(MigrationConfig.DataSourceConfig.builder()
                        .url("jdbc:mysql://localhost:3307/old_database")
                        .username("root")
                        .password("123456")
                        .driverClassName("com.mysql.cj.jdbc.Driver")
                        .build())
                // 目标数据源（新数据库）
                .target(MigrationConfig.DataSourceConfig.builder()
                        .url("jdbc:mysql://localhost:3308/new_database")
                        .username("root")
                        .password("123456")
                        .driverClassName("com.mysql.cj.jdbc.Driver")
                        .build())
                // 要迁移的表（为空则迁移所有表）
                .tables(Arrays.asList("user", "order", "product"))
                // 启用数据校验
                .enableValidation(true)
                // 批量大小
                .batchSize(1000)
                // 并发线程数
                .threadCount(4)
                // 迁移模式：全量迁移
                .mode(MigrationConfig.MigrationMode.FULL)
                .build();
        
        // 执行迁移
        MigrationResult result = migrationService.migrate(config);
        
        // 处理结果
        logMigrationResult(result);
        
        return result;
    }
    
    /**
     * 记录迁移结果
     */
    private void logMigrationResult(MigrationResult result) {
        log.info("========== 数据迁移结果 ==========");
        log.info("任务ID: {}", result.getTaskId());
        log.info("状态: {}", result.getStatus());
        log.info("总表数: {}", result.getTotalTables());
        log.info("成功表数: {}", result.getSuccessTables());
        log.info("失败表数: {}", result.getFailedTables());
        log.info("总记录数: {}", result.getTotalRecords());
        log.info("成功记录数: {}", result.getSuccessRecords());
        log.info("失败记录数: {}", result.getFailedRecords());
        log.info("耗时: {}ms", result.getDuration());
        
        // 每个表的详情
        if (result.getTableDetails() != null) {
            for (MigrationResult.TableMigrationDetail detail : result.getTableDetails()) {
                log.info("表 {}: 状态={}, 记录数={}, 成功={}, 失败={}, 耗时={}ms",
                        detail.getTableName(),
                        detail.getStatus(),
                        detail.getTotalRecords(),
                        detail.getSuccessRecords(),
                        detail.getFailedRecords(),
                        detail.getDuration());
            }
        }
        
        // 数据校验结果
        if (result.getValidationResult() != null) {
            MigrationResult.ValidationResult validation = result.getValidationResult();
            log.info("数据校验: 通过={}, 校验表数={}, 不一致表数={}, 耗时={}ms",
                    validation.isPassed(),
                    validation.getValidatedTables(),
                    validation.getInconsistentTables(),
                    validation.getDuration());
        }
        
        log.info("==================================");
    }
}
```

### 4.2 Controller 示例

```java
package com.lixiangyu.controller;

import com.lixiangyu.common.migration.DataMigrationService;
import com.lixiangyu.common.migration.MigrationConfig;
import com.lixiangyu.common.migration.MigrationResult;
import com.lixiangyu.common.util.Result;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;

@Slf4j
@RestController
@RequestMapping("/api/migration")
@RequiredArgsConstructor
public class MigrationController {
    
    private final DataMigrationService migrationService;
    
    /**
     * 执行数据迁移
     */
    @PostMapping("/execute")
    public Result<MigrationResult> executeMigration(@RequestBody MigrationRequest request) {
        try {
            MigrationConfig config = MigrationConfig.builder()
                    .source(MigrationConfig.DataSourceConfig.builder()
                            .url(request.getSourceUrl())
                            .username(request.getSourceUsername())
                            .password(request.getSourcePassword())
                            .driverClassName(request.getSourceDriver())
                            .build())
                    .target(MigrationConfig.DataSourceConfig.builder()
                            .url(request.getTargetUrl())
                            .username(request.getTargetUsername())
                            .password(request.getTargetPassword())
                            .driverClassName(request.getTargetDriver())
                            .build())
                    .tables(request.getTables())
                    .enableValidation(request.isEnableValidation())
                    .batchSize(request.getBatchSize())
                    .threadCount(request.getThreadCount())
                    .build();
            
            MigrationResult result = migrationService.migrate(config);
            return Result.success(result);
            
        } catch (Exception e) {
            log.error("执行数据迁移失败", e);
            return Result.error("迁移失败: " + e.getMessage());
        }
    }
    
    /**
     * 迁移请求对象
     */
    @lombok.Data
    public static class MigrationRequest {
        private String sourceUrl;
        private String sourceUsername;
        private String sourcePassword;
        private String sourceDriver;
        private String targetUrl;
        private String targetUsername;
        private String targetPassword;
        private String targetDriver;
        private java.util.List<String> tables;
        private boolean enableValidation = true;
        private int batchSize = 1000;
        private int threadCount = 4;
    }
}
```

### 4.3 使用注解方式（需要 AspectJ 支持）

```java
@Service
public class UserMigrationService {
    
    @Autowired
    private DataMigrationService migrationService;
    
    /**
     * 使用注解方式触发迁移
     * 注意：需要添加 AspectJ 依赖并启用 AOP
     */
    @HotMigration(
        source = "sourceDataSource",
        target = "targetDataSource",
        tables = {"user"},
        enableValidation = true,
        batchSize = 1000
    )
    public void migrateUsers() {
        // 迁移完成后执行的业务逻辑
        log.info("用户数据迁移完成");
    }
}
```

---

## 五、迁移模式说明

### 5.1 FULL（全量迁移）

**特点**：
- 一次性迁移所有数据
- 适用于首次迁移或数据量较小的场景

**使用场景**：
- 数据库搬迁
- 业务上云
- 数据库版本升级

**配置示例**：
```java
.mode(MigrationConfig.MigrationMode.FULL)
```

### 5.2 INCREMENTAL（增量迁移）

**特点**：
- 只迁移增量数据
- 需要记录上次迁移的位置

**使用场景**：
- 持续数据同步
- 数据备份
- 异地多活

**配置示例**：
```java
.mode(MigrationConfig.MigrationMode.INCREMENTAL)
.enableIncremental(true)
```

### 5.3 MIXED（混合模式）

**特点**：
- 先执行全量迁移
- 然后切换到增量同步

**使用场景**：
- 首次迁移后需要持续同步
- 数据拆分或扩容
- 异地灾备

**配置示例**：
```java
.mode(MigrationConfig.MigrationMode.MIXED)
.enableIncremental(true)
```

---

## 六、数据校验

### 6.1 校验类型

1. **记录数校验**：比较源表和目标表的记录数
2. **数据内容校验**：逐条比较数据内容（需要主键）

### 6.2 校验结果

```java
MigrationResult.ValidationResult validation = result.getValidationResult();

if (validation != null) {
    // 是否通过校验
    boolean passed = validation.isPassed();
    
    // 校验的表数
    int validatedTables = validation.getValidatedTables();
    
    // 不一致的表数
    int inconsistentTables = validation.getInconsistentTables();
    
    // 每个表的校验详情
    for (MigrationResult.TableValidationDetail detail : validation.getTableDetails()) {
        log.info("表 {}: 一致={}, 源记录数={}, 目标记录数={}",
                detail.getTableName(),
                detail.isConsistent(),
                detail.getSourceRecordCount(),
                detail.getTargetRecordCount());
        
        // 不一致的记录详情
        if (!detail.isConsistent() && detail.getInconsistentRecords() != null) {
            for (MigrationResult.InconsistentRecord record : detail.getInconsistentRecords()) {
                log.warn("不一致记录，主键: {}", record.getPrimaryKey());
            }
        }
    }
}
```

---

## 七、性能优化

### 7.1 批量大小调整

**小批量**（适合小表）：
```java
.batchSize(500)  // 每次处理 500 条
```

**大批量**（适合大表）：
```java
.batchSize(5000)  // 每次处理 5000 条
```

### 7.2 并发线程数调整

**低并发**（适合小数据量）：
```java
.threadCount(2)  // 2 个线程
```

**高并发**（适合大数据量）：
```java
.threadCount(8)  // 8 个线程
```

**注意**：线程数过多可能导致数据库连接池耗尽，建议根据实际情况调整。

### 7.3 迁移策略

1. **分表迁移**：大表可以分多次迁移
2. **错峰迁移**：在业务低峰期执行迁移
3. **增量同步**：使用增量模式减少迁移时间

---

## 八、最佳实践

### 8.1 迁移前准备

1. **备份数据**：迁移前备份源数据库
2. **测试环境验证**：先在测试环境验证迁移流程
3. **检查表结构**：确保目标数据库表结构正确
4. **准备回滚方案**：准备数据回滚方案

### 8.2 迁移执行

1. **监控迁移进度**：实时监控迁移状态
2. **记录迁移日志**：详细记录迁移过程
3. **数据校验**：迁移后执行数据校验
4. **业务验证**：验证业务功能正常

### 8.3 迁移后处理

1. **数据校验**：确保数据一致性
2. **性能测试**：测试目标数据库性能
3. **切换流量**：逐步切换业务流量
4. **监控告警**：设置监控和告警

---

## 九、注意事项

### 9.1 数据库兼容性

- **同构数据库**：完全支持（MySQL → MySQL）
- **异构数据库**：部分支持（需要处理数据类型映射）

### 9.2 数据类型映射

不同数据库的数据类型可能需要转换：
- MySQL `TEXT` → PostgreSQL `TEXT`
- MySQL `DATETIME` → PostgreSQL `TIMESTAMP`

### 9.3 主键和外键

- 迁移时会自动处理主键
- 外键约束需要在迁移后手动创建

### 9.4 大表迁移

对于大表（百万级以上），建议：
1. 使用较大的批量大小
2. 增加并发线程数
3. 分批次迁移
4. 使用增量模式

---

## 十、故障处理

### 10.1 迁移失败

**处理步骤**：
1. 查看错误日志
2. 检查数据源连接
3. 检查表结构是否匹配
4. 重试迁移

### 10.2 数据不一致

**处理步骤**：
1. 查看校验结果详情
2. 定位不一致的记录
3. 手动修复或重新迁移

### 10.3 性能问题

**处理步骤**：
1. 调整批量大小
2. 调整并发线程数
3. 优化数据库连接池
4. 检查网络带宽

---

## 十一、API 参考

### 11.1 DataMigrationService

```java
/**
 * 执行数据迁移
 * @param config 迁移配置
 * @return 迁移结果
 */
public MigrationResult migrate(MigrationConfig config)
```

### 11.2 DataValidator

```java
/**
 * 校验表数据一致性
 * @param sourceDataSource 源数据源
 * @param targetDataSource 目标数据源
 * @param tableName 表名
 * @param primaryKeys 主键列名列表
 * @return 校验结果
 */
public MigrationResult.TableValidationDetail validateTable(
        DataSource sourceDataSource,
        DataSource targetDataSource,
        String tableName,
        List<String> primaryKeys)
```

---

## 十二、总结

### 12.1 核心功能

✅ **数据迁移**：支持同构和异构数据库迁移  
✅ **数据校验**：自动验证数据一致性  
✅ **并发处理**：支持多线程并发迁移  
✅ **灵活配置**：支持多种配置方式  
✅ **完善日志**：详细的迁移日志记录  

### 12.2 适用场景

- ✅ 数据库搬迁
- ✅ 业务上云
- ✅ 数据库版本升级
- ✅ 数据拆分或扩容
- ✅ 异地多活
- ✅ 异地灾备

### 12.3 后续优化

1. 支持断点续传
2. 支持增量同步（基于 binlog）
3. 支持数据转换规则
4. 支持迁移进度实时查询
5. 支持迁移任务调度

---

## 十三、参考资源

- [DTS 数据传输服务文档](https://help.aliyun.com/product/26590.html)
- [Spring JDBC 文档](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc)
- [HikariCP 连接池文档](https://github.com/brettwooldridge/HikariCP)

